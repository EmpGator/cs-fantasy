{% load fantasy_tags %}
<style>
    .bracket-container {
        display: flex;
        align-items: center; /* Align rounds vertically */
        justify-content: center; /* Center rounds horizontally */
        overflow-x: auto;
        padding: 20px;
        background-color: #2c3e50;
        border-radius: 10px;
        min-height: 600px; /* Ensure container has height for centering */
    }
    .round {
        display: flex;
        flex-direction: column;
        justify-content: space-around; /* This creates the centered bracket look */
        flex-shrink: 0;
        margin-right: 40px;
        min-width: 280px;
        height: 100%;
    }
    .match {
        background-color: #34495e;
        border-radius: 5px;
        padding: 15px;
        margin: 15px 0;
        position: relative;
    }
    .match-title {
        color: #ecf0f1;
        font-weight: bold;
        text-align: center;
        margin-bottom: 10px;
        border-bottom: 1px solid #4a627a;
        padding-bottom: 5px;
    }
    .matchup {
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: #ecf0f1;
    }
    .team {
        flex-basis: 45%;
        text-align: center;
        font-weight: bold;
    }
    .vs-separator {
        color: #95a5a6;
    }
    .score-select-wrapper {
        margin-top: 10px;
    }
</style>

<div id="bracket-wrapper" class="bracket-container">
    {% for round_num, matches in matches_by_round.items %}
        <div class="round" data-round-num="{{ round_num }}">
            {% for match in matches %}
                {% with feeder_matches=feeder_matches_map|get_item:match.id %}
                <div class="match" 
                     id="match-{{ match.id }}" 
                     data-winner-to-match-id="{{ match.winner_to_match.id }}"
                     data-loser-to-match-id="{{ match.loser_to_match.id }}"
                     data-best-of="{{ match.best_of }}">
                    
                    <div class="match-title">{{ match.name }}</div>

                    <div class="match-content">
                        <div class="matchup">
                            <div class="team team-a" data-source-match-id="{{ feeder_matches.0 }}">
                                {% firstof match.team_a.name "TBD" %}
                            </div>
                            <span class="vs-separator">vs</span>
                            <div class="team team-b" data-source-match-id="{{ feeder_matches.1 }}">
                                {% firstof match.team_b.name "TBD" %}
                            </div>
                        </div>
                        
                        <div class="score-select-wrapper mt-2">
                            {{ match.form_field_prediction }}
                            {{ match.form_field_team_a }}
                            {{ match.form_field_team_b }}
                            <select class="bracket-score-select" disabled>
                                <option value="">Make a prediction...</option>
                            </select>
                        </div>
                    </div>
                </div>
                {% endwith %}
            {% endfor %}
        </div>
    {% endfor %}
</div>

{% block extra_scripts %}
<script>
document.addEventListener("DOMContentLoaded", function () {
    const wrapper = document.getElementById("bracket-wrapper");
    if (!wrapper) return;

    const formPrefix = "{{ form_prefix }}";
    const teamData = {};
    {% for team in all_teams %}
        teamData["{{ team.id }}"] = { id: "{{ team.id }}", name: "{{ team.name|escapejs }}" };
    {% endfor %}

    function getScoreOptions(bestOf) {
        if (![1, 3, 5].includes(bestOf)) return [];
        const winningScore = Math.floor(bestOf / 2) + 1;
        const scores = [];
        for (let i = 0; i < winningScore; i++) {
            scores.push([winningScore, i]);
        }
        return scores;
    }

    function handleSelectChange(event) {
        const select = event.target;
        const matchElement = select.closest('.match');
        const hiddenInput = matchElement.querySelector(`input[name="${formPrefix}match_${matchElement.id.replace('match-','')}"]`);
        hiddenInput.value = select.value;
        redrawBracketState();
    }

    function redrawBracketState() {
        // 1. Collect all current predictions from hidden inputs
        const predictions = new Map();
        wrapper.querySelectorAll(`.score-select-wrapper input[type="hidden"][name^="${formPrefix}match_"]`).forEach(input => {
            if (input.value && !input.name.includes('_team_')) { // Exclude _team_a and _team_b inputs
                const matchId = input.name.replace(`${formPrefix}match_`, '');
                predictions.set(matchId, input.value);
            }
        });

        // 2. Get all matches, sorted by round number
        const allMatches = Array.from(wrapper.querySelectorAll('.match'));
        allMatches.sort((a, b) => {
            const roundA = parseInt(a.closest('.round').dataset.roundNum, 10);
            const roundB = parseInt(b.closest('.round').dataset.roundNum, 10);
            return roundA - roundB;
        });

        // 3. Reset all dynamic UI elements (teams and selects)
        allMatches.forEach(matchElement => {
            const matchId = matchElement.id.replace('match-', '');
            const teamAEl = matchElement.querySelector('.team-a');
            const teamBEl = matchElement.querySelector('.team-b');
            const hiddenTeamAInput = matchElement.querySelector(`input[name="${formPrefix}match_${matchId}_team_a"]`);
            const hiddenTeamBInput = matchElement.querySelector(`input[name="${formPrefix}match_${matchId}_team_b"]`);

            // Only reset if it's not a round 1 match (which has pre-set teams from Django context)
            if (!teamAEl.dataset.sourceMatchId && !teamBEl.dataset.sourceMatchId) {
                // Round 1 matches: ensure their initial teams are set from Django context
                // This is already handled by Django's initial render, so we just read them
                // and ensure hidden inputs reflect them.
                if (hiddenTeamAInput.value === '') { // If hidden input is empty, set from initial text
                    const teamName = teamAEl.textContent.trim();
                    const teamId = Object.keys(teamData).find(key => teamData[key].name === teamName);
                    if (teamId) hiddenTeamAInput.value = teamId;
                }
                if (hiddenTeamBInput.value === '') { // If hidden input is empty, set from initial text
                    const teamName = teamBEl.textContent.trim();
                    const teamId = Object.keys(teamData).find(key => teamData[key].name === teamName);
                    if (teamId) hiddenTeamBInput.value = teamId;
                }
            } else {
                // Later round matches: reset their teams to TBD
                teamAEl.textContent = 'TBD';
                teamBEl.textContent = 'TBD';
                hiddenTeamAInput.value = '';
                hiddenTeamBInput.value = '';
            }
        });

        // 4. Simulate bracket progression based on predictions
        allMatches.forEach(matchElement => {
            const matchId = matchElement.id.replace('match-', '');
            const predictionValue = predictions.get(matchId);
            
            if (predictionValue) {
                const [winnerId, ] = predictionValue.split('_');
                const teamAId = matchElement.querySelector(`input[name="${formPrefix}match_${matchId}_team_a"]`).value;
                const teamBId = matchElement.querySelector(`input[name="${formPrefix}match_${matchId}_team_b"]`).value;
                
                if (!teamAId || !teamBId) { // Teams not yet determined for this match, cannot process prediction
                    return; 
                }

                const loserId = winnerId === teamAId ? teamBId : teamAId;
                
                // Advance winner
                const winnerNextMatchId = matchElement.dataset.winnerToMatchId;
                if (winnerNextMatchId) {
                    const winnerNextMatchElement = document.getElementById(`match-${winnerNextMatchId}`);
                    if (winnerNextMatchElement) {
                        const targetSlot = winnerNextMatchElement.querySelector(`.team[data-source-match-id="${matchId}"]`);
                        if (targetSlot) {
                            targetSlot.textContent = teamData[winnerId]?.name;
                            const teamSlot = targetSlot.classList.contains('team-a') ? 'a' : 'b';
                            const teamIdInput = winnerNextMatchElement.querySelector(`input[name="${formPrefix}match_${winnerNextMatchId}_team_${teamSlot}"]`);
                            if (teamIdInput) teamIdInput.value = winnerId;
                        }
                    }
                }

                // Advance loser
                const loserNextMatchId = matchElement.dataset.loserToMatchId;
                if (loserNextMatchId) {
                    const loserNextMatchElement = document.getElementById(`match-${loserNextMatchId}`);
                    if (loserNextMatchElement) {
                        const targetSlot = loserNextMatchElement.querySelector(`.team[data-source-match-id="${matchId}"]`);
                        if (targetSlot) {
                            targetSlot.textContent = teamData[loserId]?.name;
                            const teamSlot = targetSlot.classList.contains('team-a') ? 'a' : 'b';
                            const teamIdInput = loserNextMatchElement.querySelector(`input[name="${formPrefix}match_${loserNextMatchId}_team_${teamSlot}"]`);
                            if (teamIdInput) teamIdInput.value = loserId;
                        }
                    }
                }
            }
        });

        // 5. Populate all select dropdowns and set their values
        allMatches.forEach(matchElement => {
            populateSelect(matchElement);
        });
    }

    function populateSelect(matchElement) {
        const teamAEl = matchElement.querySelector('.team-a');
        const teamBEl = matchElement.querySelector('.team-b');
        const teamAName = teamAEl.textContent.trim();
        const teamBName = teamBEl.textContent.trim();

        const selectWrapper = matchElement.querySelector('.score-select-wrapper');
        const select = selectWrapper.querySelector('select');
        const tomSelectInstance = select.tomselect;
        const hiddenInput = selectWrapper.querySelector(`input[name="${formPrefix}match_${matchElement.id.replace('match-','')}"]`);

        if (tomSelectInstance) tomSelectInstance.destroy(); // Destroy existing TomSelect instance

        if (teamAName === 'TBD' || teamBName === 'TBD') {
            select.innerHTML = '<option value="">Awaiting teams...</option>';
            select.disabled = true;
        } else {
            const teamAId = matchElement.querySelector(`input[name="${formPrefix}match_${matchElement.id.replace('match-','')}_team_a"]`).value;
            const teamBId = matchElement.querySelector(`input[name="${formPrefix}match_${matchElement.id.replace('match-','')}_team_b"]`).value;

            const bestOf = parseInt(matchElement.dataset.bestOf, 10);
            const scoreOptions = getScoreOptions(bestOf);
            
            const options = ['<option value="">Make a prediction...</option>'];
            scoreOptions.forEach(([score1, score2]) => {
                options.push(`<option value="${teamAId}_${score1}-${score2}">${teamAName} ${score1}-${score2}</option>`);
                options.push(`<option value="${teamBId}_${score1}-${score2}">${teamBName} ${score1}-${score2}</option>`);
            });
            
            select.innerHTML = options.join('');
            select.disabled = false;
            
            if (hiddenInput.value) {
                select.value = hiddenInput.value;
            }
        }
        
        const ts = new TomSelect(select, { create: false, dropdownParent: 'body' });
        select.addEventListener('change', handleSelectChange);
        if (hiddenInput.value) {
            ts.setValue(hiddenInput.value, true); // Silently set value for TomSelect
        }
    }

    // Initial call to set up the bracket
    redrawBracketState();
});
</script>
{% endblock %}
