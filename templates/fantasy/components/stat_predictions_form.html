<div id="stat-predictions-wrapper"
     data-max-picks-per-player="{{ module_constraints.max_picks_per_player }}"
     data-max-players-per-team="{{ module_constraints.max_players_per_team }}">
  <div class="d-flex flex-wrap justify-content-center">
    {% for field in rows %}
      <div class="card m-2 stat-prediction-card"
           style="min-width: 250px;
                  max-width: 300px">
        <div class="card-header">
          <label for="{{ field.definition }}" class="form-label mb-0">
{{ field.label }}
          </label>
        </div>
        <div class="card-body">
          {% if field.description %}
            <p class="card-text text-muted small">
{{ field.description }}
            </p>
          {% endif %}
          <select name="{{ field.definition }}"
                  id="{{ field.definition }}"
                  class="form-select stat-prediction-select"
                  placeholder="Make a prediction...">
            <option value="">
Make a prediction...
            </option>
            {% for item in field.options %}
              {% if item.options %}
                 {# This is an OptionGroup #}
                <optgroup label="{{ item.name }}">
                  {% for option in item.options %}
                    <option style="color: whitesmoke"
                            value="{{ option.id }}"
                            data-tokens="{{ option.aliases|join:',' }}"
                            data-team-name="{{ item.name }}"
                            {% if field.value and field.value.0 == option.id %}
                              selected
                            {% endif %}>
                                            {{ option.name }}
                    </option>
                  {% endfor %}
                </optgroup>
              {% else %}
                 {# This is a top-level Option #}
                <option value="{{ item.id }}"
                        data-aliases="{{ item.aliases|join:',' }}"
                        data-team-name=""
                        {% if field.value and field.value.0 == item.id %}
                          selected
                        {% endif %}>
                                    {{ item.name }}
                </option>
              {% endif %}
            {% endfor %}
          </select>
          {% for error in field.errors %}
            <div class="invalid-feedback d-block">
{{ error }}
            </div>
          {% endfor %}
        </div>
      </div>
    {% endfor %}
  </div>
</div>

{% block extra_scripts %}
  <script>
document.addEventListener("DOMContentLoaded", function () {
    const wrapper = document.getElementById("stat-predictions-wrapper");
    if (!wrapper) return;

    const maxPicksPerPlayer = parseInt(wrapper.dataset.maxPicksPerPlayer, 10);
    const maxPlayersPerTeam = wrapper.dataset.maxPlayersPerTeam
        ? parseInt(wrapper.dataset.maxPlayersPerTeam, 10)
        : null;
    const playerToTeamMap = new Map();

    const selects = Array.from(
        document.querySelectorAll(".stat-prediction-select"),
    );
    const tomSelects = selects.map(
        (el) =>
            new TomSelect(el, {
                create: false,
                maxOptions: null,  // Show all options (default is 50)
                sortField: {
                    field: "text",
                    direction: "asc",
                },
                searchField: [
                  {field: 'tokens', weight: 0.8},
                  {field: 'text', weight: 2}
                ],
            }),
    );
    
    tomSelects.forEach(select => {
        Object.keys(select.options).forEach(optionId => {
            let option = select.options[optionId];
            if (option.value && option.teamName) {
                playerToTeamMap.set(option.value, option.teamName);
            }
        });
    });

    function updateDisabledOptions() {
        const selectedPlayerIds = new Map();
        const selectedTeamCounts = new Map();

        // 1. Calculate counts of selected players and teams.
        tomSelects.forEach((ts) => {
            const selectedPlayerId = ts.getValue();
            if (selectedPlayerId) {
                let currentPlayerCount = selectedPlayerIds.get(selectedPlayerId) || 0;
                selectedPlayerIds.set(
                    selectedPlayerId,
                    currentPlayerCount + 1,
                );
                const teamName = playerToTeamMap.get(selectedPlayerId);
                if (teamName) {
                    const currentTeamCount = selectedTeamCounts.get(teamName) || 0;
                    selectedTeamCounts.set(teamName, currentTeamCount + 1);
                }
            }
        });

        // 2. Apply disabling rules by calling the `updateOption` API.
        tomSelects.forEach((ts) => {
            const currentSelection = ts.getValue();
            const teamOfCurrentSelection = playerToTeamMap.get(currentSelection);
            
            Object.keys(ts.options).forEach((optionId) => {
                const originalOptionData = ts.options[optionId];
                if (!originalOptionData.value) return;

                let shouldDisable = false;
                const optionPlayerId = originalOptionData.value;
                const optionTeamName = originalOptionData.teamName || playerToTeamMap.get(optionPlayerId);
                
                const picksOfThisPlayer = selectedPlayerIds.get(optionPlayerId) || 0;
                if (picksOfThisPlayer >= maxPicksPerPlayer && optionPlayerId !== currentSelection) {
                    shouldDisable = true;
                }

                const picksFromThisTeam = selectedTeamCounts.get(optionTeamName) || 0;
                if (!shouldDisable && picksFromThisTeam >= maxPlayersPerTeam && optionTeamName !== teamOfCurrentSelection) {
                    shouldDisable = true;
                }

                // Only call the API if the state actually needs to change.
                if (originalOptionData.disabled !== shouldDisable) {
                    const newOptionData = {
                        ...originalOptionData,
                        disabled: shouldDisable,
                    };
                    ts.updateOption(optionId, newOptionData);
                }
            });
        });
    }

    tomSelects.forEach((ts) => {
        ts.on("change", updateDisabledOptions);
    });

    // Initial check on page load
    updateDisabledOptions();
});
  </script>
{% endblock extra_scripts %}
